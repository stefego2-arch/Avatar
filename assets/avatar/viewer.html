<!doctype html>
<html lang="ro">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Avatar Viewer</title>
  <style>
    html, body { margin: 0; padding: 0; overflow: hidden; background: #0f1115; }
    #c { width: 100vw; height: 100vh; display: block; }
  </style>
  
  <script type="importmap">
  {
    "imports": {
      "three": "./three/three.module.js",
      "three/addons/": "./three/"
    }
  }
  </script>
</head>
<body>
  <canvas id="c"></canvas>

  <script type="module">
    import * as THREE from 'three';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    const canvas = document.getElementById("c");
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setClearColor(0x0d1117, 1);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.80, 1.1);
    camera.lookAt(0, 1.65, 0);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444444, 2.0));
    const light = new THREE.DirectionalLight(0xffffff, 1.5);
    light.position.set(2, 2, 2);
    scene.add(light);

    const avatarGroup = new THREE.Group();
    scene.add(avatarGroup);

    let mixer, idleAction, talkAction, isTalking = false;
    const clock = new THREE.Clock();

    // Lip-sync state
    let jawMesh   = null;   // mesh-ul cu morphTarget jawOpen (dacă există)
    let jawIndex  = -1;     // indexul în morphTargetInfluences
    let _mouthTarget  = 0.0;  // valoarea trimisă din Python
    let _mouthCurrent = 0.0;  // valoarea curentă (lerp spre target)

    const loader = new GLTFLoader();
    // Încărcăm modelul tău local
    loader.load("./model5.glb", (gltf) => {
      const model = gltf.scene;
      // Model era deja cu fata spre camera (rotation.y = 0)
      // Math.PI il intorcea cu spatele — lasam 0
      model.rotation.y = +0.7;   // corecție ușoară spre stânga (~11°)
      avatarGroup.add(model);

      if (gltf.animations.length) {
        mixer = new THREE.AnimationMixer(model);
        const idleClip = gltf.animations.find(a => /idle/i.test(a.name)) || gltf.animations[0];
        const talkClip = gltf.animations.find(a => /talk|speak/i.test(a.name));

        idleAction = mixer.clipAction(idleClip);
        idleAction.play();
        if (talkClip) talkAction = mixer.clipAction(talkClip);
      }

      // Caută morph target pentru maxilar pe toate mesh-urile din model
      const JAW_NAMES = ['jawOpen','mouthOpen','Mouth_Open','jaw_open','JawOpen','mouthClose'];
      model.traverse((child) => {
        if (jawMesh) return;  // deja găsit
        if (child.isMesh && child.morphTargetDictionary) {
          for (const name of JAW_NAMES) {
            if (child.morphTargetDictionary[name] !== undefined) {
              jawMesh  = child;
              jawIndex = child.morphTargetDictionary[name];
              console.log(`[lip-sync] morph target "${name}" găsit pe "${child.name}" (idx=${jawIndex})`);
              break;
            }
          }
          if (!jawMesh) {
            // Afișează ce morph targets există (ajutor pentru debugging)
            console.log(`[lip-sync] morph targets pe "${child.name}":`, Object.keys(child.morphTargetDictionary));
          }
        }
      });
      if (!jawMesh) console.log('[lip-sync] fără morph targets — folosesc fallback animație');

    }, undefined, (e) => console.error("GLB Error:", e));

    // Apelat din Python la ~30fps cu volumul RMS normalizat [0..1]
    window.setMouthOpening = function(value) {
      _mouthTarget = value;
    };

    window.setTalking = (v) => {
      isTalking = !!v;
      if (!mixer || !talkAction) return;
      if (isTalking) {
        idleAction.fadeOut(0.2);
        talkAction.reset().fadeIn(0.2).play();
      } else {
        talkAction.fadeOut(0.2);
        idleAction.reset().fadeIn(0.2).play();
        _mouthTarget  = 0.0;  // forțăm gura închisă la oprire
      }
    };

    function animate() {
      requestAnimationFrame(animate);
      const dt = clock.getDelta();
      if (mixer) mixer.update(dt);

      // Lip-sync: lerp fluid spre target (evită tremuratul maxilarului)
      const lerpSpeed = 14.0;
      _mouthCurrent += (_mouthTarget - _mouthCurrent) * Math.min(1.0, lerpSpeed * dt);

      if (jawMesh && jawIndex >= 0) {
        // Morph target disponibil → control precis al maxilarului
        jawMesh.morphTargetInfluences[jawIndex] = _mouthCurrent;
      } else if (mixer && talkAction && isTalking) {
        // Fallback: modulăm weight-ul animației de vorbit după volum
        // (min 0.3 ca să nu dispară animația complet, max 1.0)
        talkAction.weight = 0.3 + _mouthCurrent * 0.7;
      }

      renderer.render(scene, camera);
    }
    animate();

    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>