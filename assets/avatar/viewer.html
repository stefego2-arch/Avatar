<!DOCTYPE html>
<html lang="ro">
<head>
  <meta charset="UTF-8">
  <title>Avatar</title>
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    html,body{width:100%;height:100%;overflow:hidden;background:transparent}
    canvas{display:block;width:100%!important;height:100%!important}
    #fb{display:none;position:absolute;inset:0;justify-content:center;align-items:center;
        font-size:80px;font-family:"Segoe UI Emoji","Apple Color Emoji",sans-serif;
        background:radial-gradient(ellipse at 50% 35%,#eaf6ff,#cde6f7)}
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div id="fb">ðŸ¤–</div>

  <!-- Importmap local: rezolvÄƒ bare specifier 'three' folosit intern de GLTFLoader.js -->
  <!-- GLTFLoader.js (linia 67) face: import { ... } from 'three'               -->
  <!-- FÄƒrÄƒ importmap â†’ TypeError "Failed to resolve module specifier 'three'"  -->
  <script type="importmap">
  {
    "imports": {
      "three": "./three/three.module.js"
    }
  }
  </script>

  <script type="module">
    // Importuri directe locale â€” fara CDN, fara ciclu three.core.min.js
    import * as THREE from './three/three.module.js';
    import { GLTFLoader } from './three/GLTFLoader.js';

    const canvas = document.getElementById('c');
    let mixer=null, clock=null;
    let mouthMesh=null, mouthMorphIdx=-1;
    let animActions={}, currentAction=null;
    let pendingMouth=0;

    // Renderer
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true, powerPreference:'low-power'});
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    if(THREE.SRGBColorSpace) renderer.outputColorSpace = THREE.SRGBColorSpace;

    const scene = new THREE.Scene();
    scene.background = null;

    const camera = new THREE.PerspectiveCamera(35, 1, 0.1, 100);
    camera.position.set(0, 1.35, 3.2);
    camera.lookAt(0, 1.1, 0);

    scene.add(new THREE.AmbientLight(0xfff8f0, 1.3));
    const kl = new THREE.DirectionalLight(0xfff0d8, 1.8);
    kl.position.set(1.5,3,2.5); scene.add(kl);
    const fl = new THREE.DirectionalLight(0xd8eeff, 0.7);
    fl.position.set(-1.5,1,2); scene.add(fl);

    clock = new THREE.Clock();
    resize();

    new GLTFLoader().load('./model5.glb', gltf=>{
      const model = gltf.scene;
      const box = new THREE.Box3().setFromObject(model);
      const sz = box.getSize(new THREE.Vector3());
      const ct = box.getCenter(new THREE.Vector3());
      model.position.x -= ct.x;
      model.position.z -= ct.z;
      model.position.y -= box.min.y;
      if(sz.y>0) model.scale.setScalar(2.2/sz.y);
      scene.add(model);

      if(gltf.animations?.length){
        mixer = new THREE.AnimationMixer(model);
        gltf.animations.forEach(clip=>{
          const a = mixer.clipAction(clip);
          a.setLoop(THREE.LoopRepeat, Infinity);
          animActions[clip.name]=a;
        });
        play(['idle','Idle','breathing','Breathing','stand','Stand','mixamo.com'], true);
      }

      model.traverse(nd=>{
        if(nd.isMesh && nd.morphTargetDictionary){
          for(const k of ['jawOpen','JawOpen','jaw_open','mouthOpen','MouthOpen',
                          'mouth_open','viseme_aa','viseme_open','A','a']){
            if(k in nd.morphTargetDictionary){
              mouthMorphIdx=nd.morphTargetDictionary[k]; mouthMesh=nd; break;
            }
          }
        }
      });
      console.log('[lip-sync] loaded | anims:'+Object.keys(animActions).length+' | mouth:'+(mouthMesh?.name||'none'));
    }, null, err=>{ console.error('[avatar] error:',err); showFb(); });

    let fr=0;
    (function loop(){
      requestAnimationFrame(loop);
      const dt=clock.getDelta();
      if(mixer) mixer.update(dt);
      if(++fr%2===0) applyMouth(pendingMouth);
      renderer.render(scene,camera);
    })();

    function applyMouth(v){
      if(!mouthMesh) return;
      v=Math.max(0,Math.min(1,v));
      if(mouthMorphIdx>=0 && mouthMesh.morphTargetInfluences)
        mouthMesh.morphTargetInfluences[mouthMorphIdx]=v;
      else if(mouthMesh.isBone)
        mouthMesh.rotation.x=v*0.22;
    }

    function showFb(){ canvas.style.display='none'; document.getElementById('fb').style.display='flex'; }

    function play(names, force){
      for(const n of names){
        if(animActions[n]){
          if(!force && animActions[n]===currentAction) return;
          currentAction?.fadeOut(0.35);
          animActions[n].reset().fadeIn(0.35).play();
          currentAction=animActions[n]; return;
        }
      }
      const first=Object.values(animActions)[0];
      if(first && first!==currentAction){ currentAction?.fadeOut(0.3); first.reset().fadeIn(0.3).play(); currentAction=first; }
    }

    window.addEventListener('resize', resize);
    function resize(){
      const w=window.innerWidth, h=window.innerHeight;
      renderer.setSize(w,h); camera.aspect=w/h; camera.updateProjectionMatrix();
    }

    window.setTalking=function(v){
      if(v) play(['talking','Talk','Talking','speaking','gesture','Gesture']);
      else  play(['idle','Idle','breathing','Breathing','stand','Stand','mixamo.com']);
    };
    window.setMouthOpening=function(v){ pendingMouth=parseFloat(v)||0; };
    window.setEmotion=function(emotion){
      const map={
        idle:['idle','Idle','breathing','Breathing','stand','Stand','mixamo.com'],
        happy:['happy','Happy','cheer','Cheer'],
        excited:['excited','Excited','jump','Jump','cheer'],
        talking:['talking','Talk','speaking','gesture'],
        thinking:['thinking','Thinking','idle'],
        sad:['sad','Sad','idle'],
        encouraging:['wave','Wave','nod','idle'],
      };
      const snap=currentAction;
      play(map[emotion]||map.idle);
      if(emotion!=='idle'&&emotion!=='talking')
        setTimeout(()=>{ if(currentAction===snap||!snap) window.setEmotion('idle'); },3000);
    };
  </script>
</body>
</html>